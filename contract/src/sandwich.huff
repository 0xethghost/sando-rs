// 1461446703485210103287273052203988822378723970341 is the gloabl upper bound
#define constant MAX_SQRT_PRICE_LIMIT_X96 = 0xFFFD8963EFD1FC6A506488495D951D5263988D25
// 4295128749 is the global lower bound
#define constant MIN_SQRT_PRICE_LIMIT_X96 = 0x1000276AD
#define constant UNISWAP_V3_FACTORY = 0xFF1F98431c8aD98523631AE4a59f267346ea31F9840000000000000000000000
#define constant PANCAKE_V3_FACTORY = 0xFF41ff9AA7e16B8B1a8a8dc4f0eFacd93D02d071c90000000000000000000000
#define constant SUSHISWAP_V3_FACTORY = 0xFFbaceb8ec6b9355dfc0269c18bac9d6e2bdc29c4f0000000000000000000000
#define constant UNISWAP_PAIR_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54
#define constant PANCAKE_PAIR_INIT_CODE_HASH = 0x6ce8eb472fa82df5469c6ab6d485f17c3ad13c8cd7af59b3d4a8026c5ce0f7e2

#define constant SEARCHER = 0x56272d28c6087752136b8b72C4fCC2993Ca5c4eF
#define constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

// +-------------------------------------------+
// |              Functin Sigs                 |
// +-------------------------------------------+
// Transfer(address to, uint value)
#define constant TRANSFER_SIG = 0xa9059cbb00000000000000000000000000000000000000000000000000000000
// deposit()
#define constant DEPOSIT_SIG = 0xd0e30db000000000000000000000000000000000000000000000000000000000
// withdraw(uint)
#define constant WITHDRAW_SIG = 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000
// TransferFrom(address from, address to, uint value)
#define constant TRANSFER_FROM_SIG = 0x23b872dd00000000000000000000000000000000000000000000000000000000
// Swap(uint amount0Out, uint amount1Out, address to, bytes data)
#define constant V2_SWAP_SIG_32 = 0x022c0d9f00000000000000000000000000000000000000000000000000000000
#define constant V2_SWAP_SIG_4 = 0x022c0d9f
// Swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data)
#define constant V3_SWAP_SIG_32 = 0x128acb0800000000000000000000000000000000000000000000000000000000

#define macro MAIN() = takes(0) returns (0) {
    // validate msg.sender
    [SEARCHER] caller eq                        // [is_caller_searcher]
    sandwich_entry_point
    jumpi
    v3_callback
    jump
    
    sandwich_entry_point:
        0x00
        calldataload
        0x00
        byte
        jump

    exit:
        stop

    v2_input_sigle_gate:
        v2_input_single
        jump
    
    v2_output0_single_gate:
        v2_output0_single                                // [v2_output_label]
        jump
        
    v2_output1_single_gate:
        v2_output1_single
        jump
    
    // (UniswapV3) Weth is token0 && input
    v3_input0_gate:
        v3_input0                                   // [v3_input0_label]
        jump                                        // []

    // (UniswapV3) Weth is token1 && input
    v3_input1_gate:
        v3_input1                                   // [v3_input1_label]
        jump                                        // []

    // (UniswapV3) Weth is token0 && output
    v3_output0_gate:
        v3_output0                              // [v3_output0_label]
        jump                                        // []
        
    // (UniswapV3) Weth is token1 && output
    v3_output1_gate:
        v3_output1                              // [v3_output1_label]
        jump                                        // []

    v2_input_multi_first_gate:
        v2_input_multi_first                             
        jump                                    

    v2_input_multi_next_gate:
        v2_input_multi_next
        jump

    v2_output_multi_first_gate:
        v2_output_multi_first
        jump
    
    v2_output_multi_next_gate:
        v2_output_multi_next
        jump

    prepare_stack_gate:
        prepare_stack
        jump
    
    v3_input0_multi_gate:
        v3_input0_multi
        jump
    
    v3_input1_multi_gate:
        v3_input1_multi
        jump
    
    v3_output0_multi_gate:
        v3_output0_multi
        jump

    v3_output1_multi_gate:
        v3_output1_multi
        jump

    arbitrage_weth_input_gate:
        arbitrage_weth_input
        jump

    arbitrage_v2_swap_to_other_gate:
        arbitrage_v2_swap_to_other
        jump

    arbitrage_v2_swap_to_this_gate:
        arbitrage_v2_swap_to_this
        jump

    seppuku_gate:
        seppuku                                     // [seppuku_label]
        jump                                        // []

    recover_weth_gate:
        recover_weth                                // [recover_weth_label]
        jump                                        // []
        
    deposit_weth_gate:
        deposit_weth
        jump

    // calldata: int256 amount0Delta, int256 amount1Delta, bytes data
    v3_callback:
        [SEARCHER] origin eq
        iszero gtfo2 jumpi
        // Extract pool_key_hash for msg.sender validation
        0x99 calldataload

        // uniswap v3
        // setup variables for keccak256("FF", factory_addr, pool_Key_hash, pair_hash)
        [UNISWAP_V3_FACTORY] 0x00 mstore  // [pool_key_hash] *mstore(0, ff + FACTORY)
        0x15 mstore                                 // [pool_key_hash] *mstore(21, POOLKEYHASH)
        [UNISWAP_PAIR_INIT_CODE_HASH] 0x35 mstore   // [] *mstore(53, PAIR_HASH)

        // call keccak256 and transform result to address
        0x55 0x00 sha3                    // [keccak256_result]
        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        and                                         // [pair_addr]

        // check if caller is equal to calculated pool addr
        caller eq
        v3_callback_token_transfer jumpi            // [] * Check if msg.sender is pool
        // pancake v3
        0x15 mload
        [PANCAKE_V3_FACTORY] 0x00 mstore                // [pool_key_hash] *mstore(0, ff + FACTORY)
        0x15 mstore                                 // [pool_key_hash] *mstore(21, POOLKEYHASH)
        [PANCAKE_PAIR_INIT_CODE_HASH] 0x35 mstore   // [] *mstore(53, PAIR_HASH)

        // call keccak256 and transform result to address
        0x55 0x00 sha3                              // [keccak256_result]
        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        and                                         // [pair_addr]

        // check if caller is equal to calculated pool addr
        caller eq
        v3_callback_token_transfer jumpi            // [] * Check if msg.sender is pool
        // sushiswap v3
        0x15 mload
        [SUSHISWAP_V3_FACTORY] 0x00 mstore                // [pool_key_hash] *mstore(0, ff + FACTORY)
        0x15 mstore                                 // [pool_key_hash] *mstore(21, POOLKEYHASH)
        [UNISWAP_PAIR_INIT_CODE_HASH] 0x35 mstore   // [] *mstore(53, PAIR_HASH)

        // call keccak256 and transform result to address
        0x55 0x00 sha3                              // [keccak256_result]
        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        and                                         // [pair_addr]

        // check if caller is equal to calculated pool addr
        caller eq
        v3_callback_token_transfer jumpi                 // [] * Check if msg.sender is pool
        exit jump

    v3_callback_token_transfer:
        // setup stack for when we call inputToken.transfer
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0x44    // 100 (4+32+32)                    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]

        // *** extract inputToken address
        // inputToken address bit mask
        0x00ffffffffffffffffffffffffffffffffffffffff0000000000000000000000
        0x84 calldataload and 0x58 shr              // [token_in_addr, value, argoffset, argsize, retoffset, retsize]

        // extract isZeroForOne
        0x84 calldataload 0xf8 shr                  // [isZeroForOne, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        isZeroForOne jumpi                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize]

        //
        // if execution continues here then isZeroForOne = false
        //

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] 0x00 mstore        // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x23b872dd)
        caller 0x04 mstore                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(36, msg.sender)
        0x24 calldataload 0x24 mstore               // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(56, amount1Delta)

        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        call exit jumpi                             // [*pair_swap_args]
        0x02                                        // [2]
        dup1                                        // [2, 2]
        revert                                      // revert (2,2) for wagmi

    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    isZeroForOne:
        //
        // if execution continues here then isZeroForOne = true
        //

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] 0x00 mstore        // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x23b872dd)
        caller 0x04 mstore                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(36, msg.sender)
        0x04 calldataload 0x24 mstore               // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(56, amount0Delta)

        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        call 
        exit jumpi
        chainid
        dup1
        revert
        
    v2_input_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] 0x00 mstore   // [*token_transfer_args, *pair_swap_args] - mstore(0, 0x23b872dd)
        address 0x04 mstore                         // [*token_transfer_args, *pair_swap_args] - mstore(4, address(this))
        callvalue 0x40 mstore                       // [*token_transfer_args, *pair_swap_args] - mstore(68, callvalue * 100000)
        dup1 0x24 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // call weth transferFrom
        0x00                              // [retsize, *pair_swap_args]
        0x00                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x64    // 100 (4+32+32+32)                 // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        0x00                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        0x00                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(amountOut0, amountOut1, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore                // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f00000000000000000000000000000000000000000000000000000000)
        0x00 0x04 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(32, 0x00) - clear memory
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(32, 0x00) - clear memory

        // get amountOut and store at memOffset
        0x16 calldataload
        chainid calldataload                        // extract encodedValue by removing memOffset
        0x00
        byte mstore                                 // extract memOffset and perform mstore

        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        exit jumpi
        0x00
        dup1
        revert

    v2_output0_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] 0x00 mstore        // [*token_transfer_args, *pair_swap_args] - mstore(0, TRANSFER_SIG)
        dup1 0x04 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(4, pair_address)

        // get amountIn and store at memOffset
        0x2a calldataload                           // extract encodedValue by removing memOffset
        chainid calldataload                        
        0x00 byte mstore                  // extract memOffset and perform mstore

        // call tokenIn transferFrom
        0x00                              // [retsize, *pair_swap_args]
        0x00                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x44    // 68 (4+32+32)                     // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        0x00                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        0x00                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x16 calldataload 0x60 shr                  // [token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(wethOut, 0, address(this), "")
        0x00 0x04 mstore
        0x00 0x24 mstore
        [V2_SWAP_SIG_32] callvalue add 0x00 mstore  // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f0000...000callvalue)
        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call 
        exit jumpi                                  // [] *did swap succeed without failure?
        0x00
        dup1
        revert

    v2_output1_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x00                              // [argoffseifwWIs12d&R9H@^t, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] 0x00 mstore        // [*token_transfer_args, *pair_swap_args] - mstore(0, 0xa9059cbb)
        dup1 0x04 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // get amountIn and store at memOffset
        0x2a calldataload
        chainid calldataload                        // extract encodedValue by removing memOffset
        0x00 byte mstore                  // extract memOffset and perform mstore

        // call tokenIn transfer
        0x00                              // [retsize, *pair_swap_args]
        0x00                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x44     // 68 (4+32+32)                    // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        0x00                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        0x00                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x16 calldataload 0x60 shr                  // [token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(0, wethOut, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        0x00 0x04 mstore
        callvalue 0x20 mstore                       // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(32, callvalue)
        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        exit jumpi                      // [] *did swap succeed without failure?
        0x00
        dup1
        revert

    v2_input_multi_first:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // extract amount out
        0x16 calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        // extract amount out mem offset
        chainid calldataload                        // extract encodedValue by removing memOffset
        0x00 

        0x00
        0x00
        [V2_SWAP_SIG_32] 0x00

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] 0x00 mstore   // [*token_transfer_args, *pair_swap_args] - mstore(0, 0x23b872dd)
        address 0x04 mstore                         // [*token_transfer_args, *pair_swap_args] - mstore(4, address(this))
        callvalue 0x40 mstore                       // [*token_transfer_args, *pair_swap_args] - mstore(68, callvalue * 0x1000000000)
        dup8 0x24 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // call weth transferFrom
        0x00                              // [retsize, *pair_swap_args]
        0x00                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x64    // 100 (4+32+32+32)                 // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        0x00                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        0x00                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(amountOut0, amountOut1, address(this), "")
        mstore                                      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        0x04 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, 0)
        0x24 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, 0) **Clear Memory**

        // get amountOut and store at memOffset
        byte mstore                                 // extract memOffset and perform mstore

        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call 
        0x1a
        swap1
        0x19
        calldataload
        chainid
        byte
        jumpi                   
        
        0x00
        dup1
        revert

    v2_input_multi_next:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        0x00
        0x00
        0xA4
        0x00
        0x00
        dup6 0x02 add
        calldataload
        0x60 shr

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] 0x00 mstore   // mstore(0, 0x23b872dd)
        address 0x04 mstore
        0x00 0x44 mstore
        // extract amount in
        dup7 0x1a add
        calldataload
        0xd8 shr 0x40 mstore
        dup1 0x24 mstore

        // call weth transferFrom
        0x00
        0x00
        0x64
        0x00
        0x00
        [WETH]
        gas
        call pop

        // setup calldata for swap(0, otherTokenOut, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore
        0x00 0x04 mstore
        0x00 0x24 mstore
        // extract amount out
        dup7 0x16 add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup8
        calldataload chainid byte mstore
        address 0x44 mstore
        0x80 0x64 mstore
        0x00 0x84 mstore
        gas
        call
        swap1 0x1f add
        swap1
        dup2
        calldataload 
        0x00 byte
        jumpi
        chainid
        dup1
        revert

    v2_output_multi_first:
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x40                                        // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] 0x00 mstore        // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, TRANSFER_SIG)
        dup1 0x04 mstore                            // mstore(0x04, pair_address)
        // get amountIn and store at memOffset
        0x2a calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        chainid calldataload                        // [token_amount_in, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x00 byte                         // [memOffset, token_amount_in, pair_address, value, argoffset, argsize, retoffset, retsize]
        mstore                                      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(memOffset, token_amount_in)

        // call input token transfer(to,value)
        0x00                              // [retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x00                              // [retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x44                                        // [argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x16 calldataload 0x60 shr                  // [token_address, value, argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        gas
        call pop

        // setup calldata for swap(amountout0, amountout1, address(this), "")
        callvalue 0x2d calldataload chainid byte mstore // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(offset, callvalue)
        [V2_SWAP_SIG_4] 0x24 mstore                       // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0x24, V2_SWAP_SIG_32)
        address 0x84 mstore
        0x80 0xa4 mstore

        // call swap
        gas
        call
        0x2f
        swap1
        0x2e calldataload
        chainid byte 
        jumpi
        0x00
        dup1
        revert

    v2_output_multi_next:
        0x00 0x24 mstore
        0x00
        0x00
        0xa4
        0x40
        0x00
        dup6 0x02 add 
        calldataload 0x60 shr

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] dup3 mstore
        dup7 0x2a add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup8 calldataload
        chainid byte
        mstore
        dup1 0x04 mstore

        // call input token transfer(to,value)
        0x00
        0x00
        0x44
        0x00
        0x00
        dup12 0x16 add
        calldataload 0x60 shr   // token address
        gas
        call pop

        // setup calldata for swap(amountout0, amountout1, address(this), "")
        0x00 0x44 mstore
        0x00 0x64 mstore
        dup7 0x13 add
        calldataload
        0x000000000000000000000000000000000000000000000000000000ffffffffff
        and
        dup8 0x32 add
        calldataload chainid byte
        mstore
        [V2_SWAP_SIG_4] 0x24 mstore
        address 0x84 mstore
        0x80 0xa4 mstore
        0x00 0xc4 mstore
        gas
        call
        swap1 0x34 add
        swap1
        dup2 calldataload
        0x00 byte
        jumpi
        chainid
        dup1
        revert
    
    // (UniswapV3) Weth is token0 && input && has an offset of 0
    v3_input0:
        // setup calldata for pool.swap(address(this), true, amountSpecified, minSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload 0x00 byte shr
        0x00 sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        [WETH] 0x58 shl add 0xc4 mstore             // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x1b calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)
        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00
        mload
        callvalue 0x20 shl                          // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, - callvalue << 0x20)
        gt
        and
        exit jumpi
        0x00
        dup1
        revert

    v3_input1:
        // setup calldata for pool.swap(address(this), false, amountSpecified, maxSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        // 0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, false)
        callvalue 0x20 shl          
        0x44 mstore                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, callvalue * 100000)
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        [WETH] 0x58 shl 0xc4 mstore                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x1b calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        
        0x00
        mload
        0x00 sub
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload 
        0x00 byte shr
        lt
        and
        exit jumpi
        0x00
        dup1
        revert

    v3_output0:
        // setup calldata for pool.swap(address(this), false, amountSpecified, maxSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        //0x00 0x24 mstore                          // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, false)
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload 0x00 byte 
        shr
        0x44 mstore      // [amount_in_raw, pair_address, value, argoffset, argsize, retoffset, retsize]
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x1b calldataload 0x60 shr 0x58 shl         // [input_token, pair_address, value, argoffset, argsize, retoffset, retsize]
        0xc4 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x2F calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                              // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        0x01 sub
        callvalue 0x20 shl
        lt
        and
        exit jumpi
        0x00
        dup1
        revert

    v3_output1:
        // setup calldata for pool.swap(address(this), true, amountSpecified, minSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        chainid 0x24 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        callvalue 0x20 shl
        0x00 sub
        0x44 mstore                                 // [amount_in_raw, pair_address, value, argoffset, argsize, retoffset, retsize]
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        0x1b calldataload 0x60 shr 0x58 shl         // [input_token, pair_address, value, argoffset, argsize, retoffset, retsize]
        add 0xc4 mstore                             // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x2F calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00
        mload
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload 0x00 byte 
        shr
        gt
        and
        exit jumpi
        0x00
        dup1
        revert

    v3_input0_multi:
        // setup calldata for pool.swap(address(this), true, amountSpecified, minSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        // extract amount out
        dup1 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup2 0x1a add calldataload
        0x00 byte shr
        0x00
        sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore
        // data part used for callback
        0xa0 0x84 mstore
        0x35 0xa4 mstore
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        [WETH] 0x58 shl add
        0xc4 mstore
        dup1 0x20 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                // [retsize]
        0x00                                // [retoffset, retsize]
        0xf9                                // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                                // [argoffset, argsize, retoffset, retsize]
        0x00                                // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        // extract amount in
        dup3 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup4 0x15 add calldataload
        0x00 byte shr
        gt
        and
        swap1 0x40 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        chainid
        dup1
        revert

    v3_input1_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        // extract amount in
        dup1 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup2 0x15 add calldataload
        0x00 byte shr
        0x44 mstore
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        [WETH] 0x58 shl
        0xc4 mstore
        dup1 0x20 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call

        0x00 mload
        0x01
        sub
        // extract amount out
        dup3 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup4 0x1a add calldataload
        0x00 byte shr
        lt
        and
        swap1 0x40 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        chainid
        dup1
        revert

    v3_output0_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        // extract amount in
        dup1 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup2 0x1a add calldataload
        0x00 byte shr
        0x44 mstore
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        dup1 0x20 add
        calldataload 0x60 shr 0x58 shl 
        0xc4 mstore
        dup1 0x34 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        0x01
        sub
        dup3 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup4 0x15 add calldataload
        0x00 byte shr
        lt
        and
        swap1 0x54 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        chainid
        dup1
        revert
    
    v3_output1_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        // extract amount out
        dup1 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup2 0x15 add calldataload
        0x00 byte shr
        0x00
        sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore
        // data part used for callback
        0xa0 0x84 mstore
        0x35 0xa4 mstore
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        dup2 0x20 add
        calldataload 0x60 shr 0x58 shl 
        add 0xc4 mstore
        dup1 0x34 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        dup3 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup4 0x1a add calldataload
        0x00 byte shr
        gt
        and
        swap1 0x54 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        chainid
        dup1
        revert

    prepare_stack:
        chainid
        0x00
        calldataload
        chainid
        byte
        jump

    arbitrage_weth_input:
        // setup calldata for weth transferFrom(address(this), pair, amount)
        [TRANSFER_FROM_SIG] 0x00 mstore
        address 0x04 mstore
        dup1
        0x08
        add
        calldataload 0x60 shr
        0x24 mstore
        0x00 0x44 mstore                                                    // clear memory
        dup1 chainid add
        calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x5b mstore

        // call weth transferFrom
        0x00
        dup1
        0x64
        dup2
        dup1
        [WETH]
        gas 
        call
        pop

        // jump to next
        0x06 add dup1
        calldataload 0x00 byte
        jump
    
    arbitrage_v2_swap_to_other:
        // setup calldata for swap(amountOut0, amountOut1, to, "")
        0x00 0x04 mstore
        0x00 0x24 mstore                            // clear memory
        [V2_SWAP_SIG_32] 0x00 mstore
        // extract amount out
        dup1 0x16 add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        // extract amount out memoffset
        dup2
        calldataload
        chainid
        byte
        mstore
        // extract swap to address
        dup1 0x1c add calldataload 0x60 shr
        0x44 mstore
        0x80 0x64 mstore
        0x00 0x84 mstore
        // call swap
        0x00
        dup1
        0xa4
        dup2
        dup1
        dup6 0x02 add
        calldataload 0x60 shr               // pool address
        gas
        call
        swap1
        0x1a
        add
        swap1
        dup2
        calldataload
        0x00 byte jumpi
        // revert if swap failed
        0x00
        dup1
        revert

    arbitrage_v2_swap_to_this:
        // setup calldata for swap(amountOut0, amountOut1, address(this), "")
        0x00 0x04 mstore
        0x00 0x24 mstore                            // clear memory
        [V2_SWAP_SIG_32] 0x00 mstore
        // extract amount out
        dup1 0x16 add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        // extract amount out memoffset
        dup2
        calldataload
        chainid
        byte
        mstore
        // address(this)
        address 0x44 mstore
        0x80 0x64 mstore
        0x00 0x84 mstore
        // call swap
        0x00
        dup1
        0xa4
        dup2
        dup1
        dup6 0x02 add
        calldataload 0x60 shr               // pool address
        gas
        call
        swap1
        0x1a
        add
        swap1
        dup2
        calldataload
        0x00 byte jumpi
        // revert if swap failed
        0x00
        dup1
        revert

    // incase you deploy with metamorphic factory
    seppuku:

        caller                                      // [caller]
        selfdestruct                                // []
        stop

    // +-----------+---------------------------+
    // | Bytes     |  Value                    |
    // +-----------+---------------------------+
    // | 32        |  AmountOut                |
    // +-----------+---------------------------+
    recover_weth:
        
        [WITHDRAW_SIG] callvalue add 
        0x00 mstore

        // make withdraw call
        0x00                              // [retsize]
        0x00                              // [retoffset, retsize]
        0x24  // 36 (4 + 32)                        // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize]
        call

        // transfer balance to searcher
        0x00                                        // [retsize]
        0x00                                        // [retoffset, retsize]
        0x00                                        // [argsize, retoffset, retsize]
        0x00                                        // [argoffset, argsize, retoffset, retsize]
        selfbalance                                 // [contract_value, argoffset, argsize, retoffset, retsize]
        caller                                      // [caller, contract_value, argoffset, argsize, retoffset, retsize]
        gas                                         // [gas, caller, contract_value, argoffset, argsize, retoffset, retsize]
        call
        and
        exit jumpi
        0x00
        dup1
        revert
        
    deposit_weth:
        // prepare variables for deposit call
        [DEPOSIT_SIG] 0x00 mstore

        // make deposit call
        0x00
        0x00
        0x4
        0x00
        callvalue
        [WETH]
        gas
        call 
        exit jumpi
        0x00
        dup1
        revert

    // v3 callback revert
    gtfo2:
        0x02                                        // [2]
        dup1                                        // [2, 2]
        revert                                      // revert (2,2) for wagmi
}