// 1461446703485210103287273052203988822378723970341 is the gloabl upper bound
#define constant MAX_SQRT_PRICE_LIMIT_X96 = 0xFFFD8963EFD1FC6A506488495D951D5263988D25
// 4295128749 is the global lower bound
#define constant MIN_SQRT_PRICE_LIMIT_X96 = 0x1000276AD
#define constant UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984000000000000000000000000
#define constant UNISWAP_PAIR_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54

#define constant SEARCHER = 0x0F91479f971bd0B98629311B6c9052b8363bc9A5
#define constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

// +-------------------------------------------+
// |              Functin Sigs                 |
// +-------------------------------------------+
// Transfer(address to, uint value)
#define constant TRANSFER_SIG = 0xa9059cbb00000000000000000000000000000000000000000000000000000000
// deposit()
#define constant DEPOSIT_SIG = 0xd0e30db000000000000000000000000000000000000000000000000000000000
// withdraw(uint)
#define constant WITHDRAW_SIG = 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000
// TransferFrom(address from, address to, uint value)
#define constant TRANSFER_FROM_SIG = 0x23b872dd00000000000000000000000000000000000000000000000000000000
// Swap(uint amount0Out, uint amount1Out, address to, bytes data)
#define constant V2_SWAP_SIG_32 = 0x022c0d9f00000000000000000000000000000000000000000000000000000000
#define constant V2_SWAP_SIG_4 = 0x022c0d9f
// Swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data)
#define constant V3_SWAP_SIG_32 = 0x128acb0800000000000000000000000000000000000000000000000000000000

#define macro MAIN() = takes(0) returns (0) {
    // validate msg.sender
    [SEARCHER] caller eq                        // [is_caller_searcher]
    sandwich_entry_point
    jumpi
    uniswap_v3_callback
    jump
    
    sandwich_entry_point:
        returndatasize
        calldataload
        returndatasize
        byte
        jump

    exit:
        stop

    v2_input_sigle_gate:
        v2_input_single
        jump
    
    v2_output0_single_gate:
        v2_output0_single                                // [v2_output_label]
        jump
        
    v2_output1_single_gate:
        v2_output1_single
        jump
    
    // (UniswapV3) Weth is token0 && input
    v3_input0_gate:
        v3_input0                                   // [v3_input0_label]
        jump                                        // []

    // (UniswapV3) Weth is token1 && input
    v3_input1_gate:
        v3_input1                                   // [v3_input1_label]
        jump                                        // []

    // (UniswapV3) Weth is token0 && output
    v3_output0_gate:
        v3_output0                              // [v3_output0_label]
        jump                                        // []
        
    // (UniswapV3) Weth is token1 && output
    v3_output1_gate:
        v3_output1                              // [v3_output1_label]
        jump                                        // []

    v2_input_multi_first_gate:
        v2_input_multi_first                             
        jump                                    

    v2_input_multi_next_gate:
        v2_input_multi_next
        jump

    v2_output_multi_first_gate:
        v2_output_multi_first
        jump
    
    v2_output_multi_next_gate:
        v2_output_multi_next
        jump

    v3_multi_pre_gate:
        v3_multi_pre
        jump
    
    v3_input0_multi_gate:
        v3_input0_multi
        jump
    
    v3_input1_multi_gate:
        v3_input1_multi
        jump
    
    v3_output0_multi_gate:
        v3_output0_multi
        jump

    v3_output1_multi_gate:
        v3_output1_multi
        jump

    seppuku_gate:
        seppuku                                     // [seppuku_label]
        jump                                        // []

    recover_weth_gate:
        recover_weth                                // [recover_weth_label]
        jump                                        // []
        
    deposit_weth_gate:
        deposit_weth
        jump

    // calldata: int256 amount0Delta, int256 amount1Delta, bytes data
    uniswap_v3_callback:
        [SEARCHER] origin eq
        iszero gtfo1 jumpi
        // Extract pool_key_hash for msg.sender validation
        0x99 calldataload

        // setup variables for keccak256("FF", factory_addr, pool_Key_hash, pool_key_hash)
        __RIGHTPAD(0xFF) returndatasize mstore                // [pool_key_hash] *mstore(0, ff)
        [UNISWAP_V3_FACTORY] chainid mstore                    // [pool_key_hash] *mstore(1, FACTORY)
        0x15 mstore                                 // [pool_key_hash] *mstore(21, POOLKEYHASH)
        [UNISWAP_PAIR_INIT_CODE_HASH] 0x35 mstore           // [] *mstore(53, PAIR_HASH)

        // call keccak256 and transform result to address
        0x55 returndatasize sha3                              // [keccak256_result]
        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
        and                                         // [pair_addr]

        // check if caller is equal to calculated pool addr
        caller eq
        iszero exit jumpi                 // [] * Check if msg.sender is pool

        // setup stack for when we call inputToken.transfer
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0x44    // 100 (4+32+32)                    // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]

        // *** extract inputToken address
        // inputToken address bit mask
        0x00ffffffffffffffffffffffffffffffffffffffff0000000000000000000000
        0x84 calldataload and 0x58 shr              // [token_in_addr, value, argoffset, argsize, retoffset, retsize]

        // extract isZeroForOne
        0x84 calldataload 0xf8 shr                  // [isZeroForOne, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        isZeroForOne jumpi                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize]

        //
        // if execution continues here then isZeroForOne = false
        //

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] returndatasize mstore        // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x23b872dd)
        caller 0x04 mstore                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(36, msg.sender)
        0x24 calldataload 0x24 mstore               // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(56, amount1Delta)

        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        call exit jumpi                             // [*pair_swap_args]
        gtfo1 jump

    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    // ****KEEP THIS LABEL UNJUMPABLE TO IF YOU EVER INCREASE JUMP_LABEL IN CALLDATA FROM 1BYTES to 2BYTES****
    isZeroForOne:
        //
        // if execution continues here then isZeroForOne = true
        //

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] returndatasize mstore        // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x23b872dd)
        caller 0x04 mstore                          // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(36, msg.sender)
        0x04 calldataload 0x24 mstore               // [token_in_addr, value, argoffset, argsize, retoffset, retsize] - mstore(56, amount0Delta)

        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize]
        call 
        exit jumpi
        gtfo1 jump
        
    v2_input_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] returndatasize mstore   // [*token_transfer_args, *pair_swap_args] - mstore(0, 0x23b872dd)
        address 0x04 mstore                         // [*token_transfer_args, *pair_swap_args] - mstore(4, address(this))
        callvalue 0x40 mstore                       // [*token_transfer_args, *pair_swap_args] - mstore(68, callvalue * 100000)
        dup1 0x24 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // call weth transferFrom
        returndatasize                              // [retsize, *pair_swap_args]
        returndatasize                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x64    // 100 (4+32+32+32)                 // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        returndatasize                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(amountOut0, amountOut1, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore                // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        0x00 0x04 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, 0)
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, 0) **Clear Memory**

        // get amountOut and store at memOffset
        0x16 calldataload
        chainid calldataload                        // extract encodedValue by removing memOffset
        0x00
        byte mstore                                 // extract memOffset and perform mstore

        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        exit jumpi
        gtfo0 jump

    v2_output0_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] returndatasize mstore        // [*token_transfer_args, *pair_swap_args] - mstore(0, TRANSFER_SIG)
        dup1 0x04 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(4, pair_address)

        // get amountIn and store at memOffset
        0x2a calldataload
        chainid calldataload                        // extract encodedValue by removing memOffset
        returndatasize byte mstore                            // extract memOffset and perform mstore

        // call tokenIn transferFrom
        returndatasize                              // [retsize, *pair_swap_args]
        returndatasize                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x44    // 68 (4+32+32)                     // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        returndatasize                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x16 calldataload 0x60 shr                  // [token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(wethOut, 0, address(this), "")
        0x00 0x04 mstore
        0x00 0x24 mstore
        [V2_SWAP_SIG_32] callvalue add 0x00 mstore                       // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f0000...000callvalue)
        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call 
        exit jumpi                      // [] *did swap succeed without failure?
        gtfo0 jump

    v2_output1_single:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        returndatasize                              // [argoffseifwWIs12d&R9H@^t, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] returndatasize mstore        // [*token_transfer_args, *pair_swap_args] - mstore(0, 0xa9059cbb)
        dup1 0x04 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // get amountIn and store at memOffset
        0x2a calldataload
        chainid calldataload                              // extract encodedValue by removing memOffset
        returndatasize byte mstore                            // extract memOffset and perform mstore

        // call tokenIn transfer
        returndatasize                              // [retsize, *pair_swap_args]
        returndatasize                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x44     // 68 (4+32+32)                    // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        returndatasize                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x16 calldataload 0x60 shr                  // [token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, token_in_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(0, wethOut, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        0x00 0x04 mstore
        callvalue 0x20 mstore                       // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(32, callvalue)
        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        exit jumpi                      // [] *did swap succeed without failure?
        gtfo0 jump

    v2_input_multi_first:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // extract amount out
        0x16 calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        // extract amount out mem offset
        chainid calldataload                        // extract encodedValue by removing memOffset
        returndatasize 

        returndatasize
        returndatasize
        [V2_SWAP_SIG_32] returndatasize

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] returndatasize mstore   // [*token_transfer_args, *pair_swap_args] - mstore(0, 0x23b872dd)
        address 0x04 mstore                         // [*token_transfer_args, *pair_swap_args] - mstore(4, address(this))
        callvalue 0x40 mstore                       // [*token_transfer_args, *pair_swap_args] - mstore(68, callvalue * 0x1000000000)
        dup8 0x24 mstore                            // [*token_transfer_args, *pair_swap_args] - mstore(36, pair_address)

        // call weth transferFrom
        returndatasize                              // [retsize, *pair_swap_args]
        returndatasize                              // [retoffset, retsize, *pair_swap_args] = token_transfer_args
        0x64    // 100 (4+32+32+32)                 // [argsize, retoffset, retsize, *pair_swap_args] !expanded token_transfer_args
        returndatasize                              // [argoffset, argsize, retoffset, retsize, *pair_swap_args]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize, *pair_swap_args] = token_transfer_args
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize, *pair_swap_args]
        call pop                                    // [*pair_swap_args]
                                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] !expanded pair_swap_args

        // setup calldata for swap(amountOut0, amountOut1, address(this), "")
        mstore                                      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        0x04 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, 0)
        0x24 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, 0) **Clear Memory**

        // get amountIn and store at memOffset
        byte mstore                                 // extract memOffset and perform mstore

        address 0x44 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, address(this))
        0x80 0x64 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, 0x80) 4 + 32 + 32 + 32, 0x80 because bytes is dynamic

        // call pair.swap
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call 
        0x1a
        swap1
        0x19
        calldataload
        chainid
        byte
        jumpi                   
        
        gtfo0 jump

    v2_input_multi_next:
        // ***Preset the stack for when we call pair.swap(token0Out, token1Out, to, data)***
        returndatasize
        returndatasize
        0xA4
        returndatasize
        returndatasize
        dup6 0x02 add
        calldataload
        0x60 shr

        // setup calldata for transferFrom(from,to,value)
        [TRANSFER_FROM_SIG] returndatasize mstore   // mstore(0, 0x23b872dd)
        address 0x04 mstore
        returndatasize 0x44 mstore
        // extract amount in
        dup7 0x1a add
        calldataload
        0xd8 shr 0x40 mstore
        dup1 0x24 mstore

        // call weth transferFrom
        returndatasize
        returndatasize
        0x64
        returndatasize
        returndatasize
        [WETH]
        gas
        call pop

        // setup calldata for swap(0, otherTokenOut, address(this), "")
        [V2_SWAP_SIG_32] 0x00 mstore
        0x00 0x04 mstore
        0x00 0x24 mstore
        // extract amount out
        dup7 0x16 add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup8
        calldataload chainid byte mstore
        address 0x44 mstore
        0x80 0x64 mstore
        0x00 0x84 mstore
        gas
        call
        swap1 0x1f add
        swap1
        dup2
        calldataload 
        0x00 byte
        jumpi
        gtfo1 jump

    v2_output_multi_first:
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xA4  // 164 (4 + 32 + 32 + 32 + {32 + 32}) // [argsize, retoffset, retsize]
        0x40                                        // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        0x02 calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] returndatasize mstore        // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, TRANSFER_SIG)
        0x2a calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and                                         // [token_amount_in, pair_address, value, argoffset, argsize, retoffset, retsize]
        chainid calldataload                        
        returndatasize byte                         // [memOffset, token_amount_in, pair_address, value, argoffset, argsize, retoffset, retsize]
        mstore                                      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(memOffset, token_amount_in)
        dup1 0x04 mstore                            // mstore(0x04, pair_address)

        // call input token transfer(to,value)
        returndatasize                              // [retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        returndatasize                              // [retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x44                                        // [argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        0x16 calldataload 0x60 shr                  // [token_address, value, argoffset, argsize, retoffset, retsize, pair_address, value, argoffset, argsize, retoffset, retsize]
        gas
        call pop

        // setup calldata for swap(amountout0, amountout1, address(this), "")
        callvalue 0x2d calldataload chainid byte mstore // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(offset, callvalue)
        [V2_SWAP_SIG_4] 0x24 mstore                       // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0x24, V2_SWAP_SIG_32)
        address 0x84 mstore
        0x80 0xa4 mstore

        // call swap
        gas
        call
        0x2f
        swap1
        0x2e calldataload
        chainid byte 
        jumpi
        gtfo0 jump

    v2_output_multi_next:
        0x00 0x24 mstore
        0x00
        0x00
        0xa4
        0x40
        0x00
        dup6 0x02 add 
        calldataload 0x60 shr

        // setup calldata (in memory) for transfer(to,value)
        [TRANSFER_SIG] dup3 mstore
        dup7 0x2a add
        calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup8 calldataload
        chainid byte
        mstore
        dup1 0x04 mstore

        // call input token transfer(to,value)
        0x00
        0x00
        0x44
        0x00
        0x00
        dup12 0x16 add
        calldataload 0x60 shr   // token address
        gas
        call pop

        // setup calldata for swap(amountout0, amountout1, address(this), "")
        0x00 0x44 mstore
        0x00 0x64 mstore
        dup7 0x13 add
        calldataload
        0x000000000000000000000000000000000000000000000000000000ffffffffff
        and
        dup8 0x32 add
        calldataload chainid byte
        mstore
        [V2_SWAP_SIG_4] 0x24 mstore
        address 0x84 mstore
        0x80 0xa4 mstore
        0x00 0xc4 mstore
        gas
        call
        swap1 0x34 add
        swap1
        dup2 calldataload
        0x00 byte
        jumpi
        gtfo1 jump
    
    // (UniswapV3) Weth is token0 && input && has an offset of 0
    v3_input0:
        // setup calldata for pool.swap(address(this), true, amountSpecified, minSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] 0x00 mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload returndatasize byte shr
        returndatasize sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        [WETH] 0x58 shl add 0xc4 mstore             // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x1b calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)
        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00
        mload
        callvalue 0x20 shl                          // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, - callvalue << 0x20)
        gt
        and
        exit jumpi
        gtfo0 jump

    v3_input1:
        // setup calldata for pool.swap(address(this), true, amountSpecified, maxSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] returndatasize mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        // returndatasize 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, false)
        callvalue 0x20 shl          
        0x44 mstore                                    // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(68, callvalue * 100000)
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        [WETH] 0x58 shl 0xc4 mstore                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x1b calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr                  // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        
        returndatasize
        mload
        returndatasize
        sub
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload 
        returndatasize byte shr
        lt
        and
        exit jumpi
        gtfo0 jump

    v3_output0:
        // setup calldata for pool.swap(address(this), true, amountSpecified, maxSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] returndatasize mstore                   // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        //0x00 0x24 mstore                          // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, false)
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload returndatasize byte 
        shr
        0x44 mstore      // [amount_in_raw, pair_address, value, argoffset, argsize, retoffset, retsize]
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x1b calldataload 0x60 shr 0x58 shl         // [input_token, pair_address, value, argoffset, argsize, retoffset, retsize]
        0xc4 mstore                                 // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x2F calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        returndatasize mload
        returndatasize sub
        callvalue 0x20 shl
        lt
        and
        exit jumpi
        gtfo0 jump

    v3_output1:
        // setup calldata for pool.swap(address(this), true, amountSpecified, minSqrtPriceLimitX96, data)
        [V3_SWAP_SIG_32] returndatasize mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(0, 0x022c0d9f)
        address 0x04 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(4, address(this))
        chainid 0x24 mstore                         // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        callvalue 0x20 shl
        returndatasize sub
        0x44 mstore                                 // [amount_in_raw, pair_address, value, argoffset, argsize, retoffset, retsize]
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        0x1b calldataload 0x60 shr 0x58 shl         // [input_token, pair_address, value, argoffset, argsize, retoffset, retsize]
        add 0xc4 mstore                             // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(196, isZeroForOne_&_InputTokenAddr)
        0x2F calldataload 0xd9 mstore               // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(217, pool_key_hash)

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        returndatasize                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        chainid calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        returndatasize
        mload
        0x16 calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        0x15 calldataload returndatasize byte 
        shr
        gt
        and
        exit jumpi
        gtfo0 jump

    v3_input0_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        dup1 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup2 0x1a add calldataload
        0x00 byte shr
        0x00
        sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore
        // data part used for callback
        0xa0 0x84 mstore
        0x35 0xa4 mstore
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        [WETH] 0x58 shl add
        0xc4 mstore
        dup1 0x20 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                // [retsize]
        0x00                                // [retoffset, retsize]
        0xf9                                // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                                // [argoffset, argsize, retoffset, retsize]
        0x00                                // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        dup3 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup4 0x15 add calldataload
        0x00 byte shr
        gt
        and
        swap1 0x40 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        gtfo1 jump

    v3_input1_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        dup1 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup2 0x15 add calldataload
        0x00 byte shr
        0x44 mstore
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        [WETH] 0x58 shl
        0xc4 mstore
        dup1 0x20 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call

        0x00 mload
        returndatasize
        sub
        dup3 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup4 0x1a add calldataload
        0x00 byte shr
        lt
        and
        swap1 0x40 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        gtfo1 jump

    v3_output0_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        0x00 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        dup1 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup2 0x1a add calldataload
        0x00 byte shr
        0x44 mstore
        [MAX_SQRT_PRICE_LIMIT_X96] 0x64 mstore      // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(100, address(this))
        // data part used for callback
        0xa0 0x84 mstore // 100                     // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(132, 0x80) *dynamic byte offset
        0x35 0xa4 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(164, 0x02) *dynamic byte length
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        dup1 0x20 add
        calldataload 0x60 shr 0x58 shl 
        0xc4 mstore
        dup1 0x34 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        returndatasize
        sub
        dup3 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup4 0x15 add calldataload
        0x00 byte shr
        lt
        and
        swap1 0x54 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        gtfo1 jump
    
    v3_output1_multi:
        [V3_SWAP_SIG_32] 0x00 mstore
        address 0x04 mstore
        chainid 0x24 mstore                            // [pair_address, value, argoffset, argsize, retoffset, retsize] - mstore(36, true)
        dup1 0x16 add calldataload
        0xffffffff00000000000000000000000000000000000000000000000000000000
        and
        dup2 0x15 add calldataload
        0x00 byte shr
        0x00
        sub
        0x44 mstore
        [MIN_SQRT_PRICE_LIMIT_X96] 0x64 mstore
        // data part used for callback
        0xa0 0x84 mstore
        0x35 0xa4 mstore
        // ** abi.encodePacked(isZeroForOne, input_token, pool_key_hash)
        0x0100000000000000000000000000000000000000000000000000000000000000
        dup2 0x20 add
        calldataload 0x60 shr 0x58 shl 
        add 0xc4 mstore
        dup1 0x34 add
        calldataload 0xd9 mstore

        // call pool.swap
        // ***Preset the stack for when we call pool.swap(recipient, zeroForOne, amountSpecified, sqrtPriceLimitX96, data)
        0x40                                        // [retsize]
        0x00                              // [retoffset, retsize]
        0xf9   // 249 (4+32+32+32+32+{32+32+53})    // [argsize, retoffset, retsize]
        0x00                              // [argoffset, argsize, retoffset, retsize]
        0x00                              // [value, argoffset, argsize, retoffset, retsize]
        dup6 chainid add calldataload 0x60 shr               // [pair_address, value, argoffset, argsize, retoffset, retsize] = pair_swap_args
        gas                                         // [gas, pair_address, value, argoffset, argsize, retoffset, retsize]
        call
        0x00 mload
        dup3 0x1b add calldataload
        0xffffffffff000000000000000000000000000000000000000000000000000000
        and
        dup4 0x1a add calldataload
        0x00 byte shr
        gt
        and
        swap1 0x54 add
        swap1
        dup2 calldataload 0x00 byte
        jumpi
        gtfo1 jump

    v3_multi_pre:
        chainid
        returndatasize
        calldataload
        chainid
        byte
        jump
        
    // incase you deploy with metamorphic factory
    seppuku:

        caller                                      // [caller]
        selfdestruct                                // []
        stop

    // +-----------+---------------------------+
    // | Bytes     |  Value                    |
    // +-----------+---------------------------+
    // | 32        |  AmountOut                |
    // +-----------+---------------------------+
    recover_weth:
        
        [WITHDRAW_SIG] callvalue add 
        returndatasize mstore

        // make withdraw call
        returndatasize                              // [retsize]
        returndatasize                              // [retoffset, retsize]
        0x24  // 36 (4 + 32)                        // [argsize, retoffset, retsize]
        returndatasize                              // [argoffset, argsize, retoffset, retsize]
        returndatasize                              // [value, argoffset, argsize, retoffset, retsize]
        [WETH]                                      // [weth_addr, value, argoffset, argsize, retoffset, retsize]
        gas                                         // [gas, weth_addr, value, argoffset, argsize, retoffset, retsize]
        call

        // transfer balance to searcher
        returndatasize                                        // [retsize]
        returndatasize                                        // [retoffset, retsize]
        returndatasize                                        // [argsize, retoffset, retsize]
        returndatasize                                        // [argoffset, argsize, retoffset, retsize]
        selfbalance                                 // [contract_value, argoffset, argsize, retoffset, retsize]
        caller                                      // [caller, contract_value, argoffset, argsize, retoffset, retsize]
        gas                                         // [gas, caller, contract_value, argoffset, argsize, retoffset, retsize]
        call
        and
        exit jumpi
        gtfo0 jump
        
    deposit_weth:
        // prepare variables for deposit call
        [DEPOSIT_SIG] returndatasize mstore

        // make deposit call
        returndatasize
        returndatasize
        0x4
        returndatasize
        callvalue
        [WETH]
        gas
        call 
        exit jumpi
        gtfo0 jump

    gtfo0:
        0x00                                        // [0]
        dup1                                        // [0, 0]
        revert                                      // revert (0,0) for wagmi
        
    gtfo1:
        chainid                                        // [1]
        dup1                                        // [1, 1]
        revert                                      // revert (0,0) for wagmi
}